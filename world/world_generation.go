package world

import (
	"bytes"
	"io/ioutil"
	"math"
	"math/rand"
	"strings"

	"github.com/onorton/cowboysindians/item"
	"github.com/onorton/cowboysindians/npc"
	"github.com/onorton/cowboysindians/player"
	"github.com/onorton/cowboysindians/structs"
	"github.com/onorton/cowboysindians/worldmap"
)

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func GenerateWorld(filename string) (*player.Player, []*npc.Npc) {
	world := worldmap.NewWorld(worldConf.Width, worldConf.Height)

	towns := make([]worldmap.Town, 0)
	buildings := make([]worldmap.Building, 0)

	for i := 0; i < worldConf.Towns; i++ {
		generateTown(world, &towns, &buildings)
	}

	for i := 0; i < worldConf.Farms; i++ {
		generateFarm(world, &towns, &buildings)
	}

	generatePaths(world, towns)

	// Generate buildings outside towns
	for i := 0; i < worldConf.OutBuildings; i++ {
		generateBuildingOutsideTown(world, &towns, &buildings)
	}

	placeSignposts(world, towns)
	addItemsToBuildings(world, buildings)

	location := generatePlayerLocation(world, towns)

	p := player.CreatePlayer(location)

	mounts := generateMounts(world, buildings, worldConf.Mounts)
	enemies := generateEnemies(world, worldConf.Enemies)
	npcs := generateNpcs(world, towns, buildings, worldConf.Npcs)

	npcs = append(npcs, enemies...)
	// Add mounts generated by npcs
	for _, npc := range npcs {
		if mount := npc.Mount(); mount != nil {
			mounts = append(mounts, mount)
		}
	}
	npcs = append(npcs, mounts...)

	worldJson, err := world.MarshalJSON()
	check(err)
	buffer := bytes.NewBufferString("{")
	buffer.Write(worldJson)
	buffer.WriteString("}")

	err = ioutil.WriteFile(filename, buffer.Bytes(), 0644)
	check(err)
	return p, npcs
}

func addItemsToBuildings(world worldmap.World, buildings []worldmap.Building) {
	for _, b := range buildings {

		// Consider inner area (exclude walls)
		x1, y1 := b.Area.X1()+1, b.Area.Y1()+1
		x2, y2 := b.Area.X2()-1, b.Area.Y2()-1

		// Create and place a key for the door somewhere in the building
		keyValue := world.Door(b.DoorLocation.X, b.DoorLocation.Y).Key()

		for {
			// Select a random location
			x := x1 + rand.Intn(x2-x1)
			y := y1 + rand.Intn(y2-y1)

			if world.IsPassable(x, y) {
				world.PlaceItem(x, y, item.NewKey(keyValue))
				break
			}
		}

		// If Saloon, place chairs and tables
		if b.T == worldmap.Saloon {

			// Chairs and tables should not be close to counter or front door
			if b.DoorLocation.X == b.Area.X1() {
				x1 += 1
				x2 -= 3
			} else if b.DoorLocation.X == b.Area.X2() {
				x1 += 3
				x2 -= 1
			} else if b.DoorLocation.Y == b.Area.Y1() {
				y1 += 1
				y2 -= 3
			} else if b.DoorLocation.Y == b.Area.Y2() {
				y1 += 3
				y2 -= 1
			}

			for x := x1; x <= x2; x += 4 {
				for y := y1; y <= y2; y += 4 {
					// If a free 3x3 space exists, add a table and four chairs
					if x >= x1 && x+2 <= x2 && y >= y1 && y+2 <= y2 {
						world.PlaceItem(x+1, y+1, item.NewNormalItem("table"))
						world.PlaceItem(x, y+1, item.NewNormalItem("chair"))
						world.PlaceItem(x+1, y, item.NewNormalItem("chair"))
						world.PlaceItem(x+2, y+1, item.NewNormalItem("chair"))
						world.PlaceItem(x+1, y+2, item.NewNormalItem("chair"))
					}
				}
			}

		} else if b.T != worldmap.Sheriff {

			buildingArea := (x2 - x1) * (y2 - y1)

			numOfItems := buildingArea / 2

			for i := 0; i < numOfItems; i++ {

				// Select a random location
				x := x1 + rand.Intn(x2-x1)
				y := y1 + rand.Intn(y2-y1)

				if world.IsPassable(x, y) {
					world.PlaceItem(x, y, item.GenerateItem())
				} else {
					i--
				}
			}
		}
	}

}

// Generate a rectangular building and place on map
func generateBuildingOutsideTown(world worldmap.World, towns *[]worldmap.Town, buildings *[]worldmap.Building) {
	width := world.Width()
	height := world.Height()

	validBuilding := false

	// Keeps trying until a usable building position and size found
	for !validBuilding {
		// Has to be at least three squares wide
		buildingWidth := rand.Intn(3) + 3
		buildingHeight := rand.Intn(3) + 3

		posWidth := 0
		negWidth := 0
		posHeight := 0
		negHeight := 0

		if buildingWidth%2 == 0 {
			posWidth, negWidth = buildingWidth/2, buildingWidth/2
		} else {
			posWidth, negWidth = (buildingWidth+1)/2, buildingWidth/2
		}

		if buildingHeight%2 == 0 {
			posHeight, negHeight = buildingHeight/2, buildingHeight/2
		} else {
			posHeight, negHeight = (buildingHeight+1)/2, buildingHeight/2
		}

		// stop it from reaching the edges of the map
		cX := rand.Intn(width-posWidth) + negWidth
		cY := rand.Intn(height-posHeight) + negHeight

		x1, y1 := cX-negWidth, cY-negHeight
		x2, y2 := cX+posWidth, cY+posHeight

		b := worldmap.NewBuilding(x1, y1, x2, y2, worldmap.Residential)
		validBuilding = isValid(x1, y1, width, height) && isValid(x2, y2, width, height) && !overlap(*buildings, b) && !inTowns(*towns, b)

		if validBuilding {
			// Add walls
			for x := x1; x <= x2; x++ {
				world.NewTile("wall", x, y1)
				world.NewTile("wall", x, y2)
			}

			for y := y1; y <= y2; y++ {
				world.NewTile("wall", x1, y)
				world.NewTile("wall", x2, y)
			}

			// Add door randomly as long it's not a corner
			wallSelection := rand.Intn(4)

			// Wall selection is North, South, East, West
			doorX, doorY := 0, 0
			switch wallSelection {
			case 0:
				doorX = x1 + 1 + rand.Intn(buildingWidth-2)
				doorY = y1
			case 1:
				doorX = x1 + 1 + rand.Intn(buildingWidth-2)
				doorY = y2
			case 2:
				doorY = y1 + 1 + rand.Intn(buildingHeight-2)
				doorX = x2
			case 3:
				doorY = y1 + 1 + rand.Intn(buildingHeight-2)
				doorX = x1
			}
			world.NewTile("door", doorX, doorY)
			world.Door(doorX, doorY).Lock()
			b.DoorLocation = &worldmap.Coordinates{doorX, doorY}

			// Add number of windows accbording total perimeter of building
			perimeter := 2*(y2-y1) + 2*(x2-x1)
			minNumWindows := perimeter / 5
			maxNumWindows := perimeter / 3
			numWindows := minNumWindows + rand.Intn(maxNumWindows-minNumWindows)

			for i := 0; i < numWindows; i++ {

				wallSelection = rand.Intn(4)
				wX, wY := 0, 0

				switch wallSelection {
				case 0:
					doorX := x1 + 1 + rand.Intn(buildingWidth-2)
					wX, wY = doorX, y1
				case 1:
					doorX := x1 + 1 + rand.Intn(buildingWidth-2)
					wX, wY = doorX, y2
				case 2:
					doorY := y1 + 1 + rand.Intn(buildingHeight-2)
					wX, wY = x2, doorY
				case 3:
					doorY := y1 + 1 + rand.Intn(buildingHeight-2)
					wX, wY = x1, doorY
				}

				// If a door is not in place, add window. Otherwise, try again.
				if wX != doorX && wY != doorY {
					world.NewTile("window", wX, wY)
				} else {
					i--
				}
			}

			*buildings = append(*buildings, b)
		}
	}
}

func randomBuildingType(buildings *[]worldmap.Building) worldmap.BuildingType {
	// 1/2 chance of being residential
	residential := rand.Intn(2) == 0

	if residential {
		return worldmap.Residential
	} else {
		for {
			commercialType := worldmap.BuildingType(rand.Intn(3) + 1)
			// Only one sheriff
			if commercialType == worldmap.Sheriff {

				sheriffExists := false
				for _, b := range *buildings {
					if b.T == worldmap.Sheriff {
						sheriffExists = true
					}
				}
				if !sheriffExists {
					return commercialType
				}
			} else {
				return commercialType
			}
		}
	}
}

func generateBuildingInTown(world worldmap.World, t *worldmap.Town, buildings *[]worldmap.Building, buildingType worldmap.BuildingType) {
	validBuilding := false
	// Keeps trying until a usable building position and size found
	for !validBuilding {

		// Must be at least 3 in each dimension

		// Width along the street
		buildingWidth := rand.Intn(5) + 3
		depth := rand.Intn(5) + 3
		// Commerical buildings would be larger
		if buildingType != worldmap.Residential {
			buildingWidth = rand.Intn(10) + 8
			depth = rand.Intn(10) + 8
		}

		posWidth := 0
		negWidth := 0

		if buildingWidth%2 == 0 {
			posWidth, negWidth = buildingWidth/2, buildingWidth/2
		} else {
			posWidth, negWidth = (buildingWidth+1)/2, buildingWidth/2
		}

		x1, y1 := 0, 0
		x2, y2 := 0, 0

		sideOfStreet := rand.Intn(2) == 0

		if t.Horizontal {
			centreAlongStreet := t.StreetArea.X1() + 1 + rand.Intn(t.StreetArea.X2()-t.StreetArea.X1()-2)
			x1 = centreAlongStreet - negWidth
			x2 = centreAlongStreet + posWidth

			if sideOfStreet {
				y2 = t.StreetArea.Y1() - 1
				y1 = y2 - depth
			} else {
				y1 = t.StreetArea.Y2() + 1
				y2 = y1 + depth
			}
		} else {
			centreAlongStreet := t.StreetArea.Y1() + 1 + rand.Intn(t.StreetArea.Y2()-t.StreetArea.Y1()-2)
			y1 = centreAlongStreet - negWidth
			y2 = centreAlongStreet + posWidth

			if sideOfStreet {
				x2 = t.StreetArea.X1() - 1
				x1 = x2 - depth
			} else {
				x1 = t.StreetArea.X2() + 1
				x2 = x1 + depth
			}
		}

		b := worldmap.NewBuilding(x1, y1, x2, y2, buildingType)
		validBuilding = inTown(*t, b) && !overlap(*buildings, b)

		if validBuilding {
			// Add walls
			for x := x1; x <= x2; x++ {
				world.NewTile("wall", x, y1)
				world.NewTile("wall", x, y2)
			}

			for y := y1; y <= y2; y++ {
				world.NewTile("wall", x1, y)
				world.NewTile("wall", x2, y)
			}

			for y := y1 + 1; y <= y2-1; y++ {
				for x := x1 + 1; x <= x2-1; x++ {
					world.NewTile("ground", x, y)
				}
			}

			doorX, doorY := 0, 0
			// Door is on side facing street
			if t.Horizontal {
				doorX = x1 + 1 + rand.Intn(buildingWidth-2)
				if sideOfStreet {
					doorY = y2
				} else {
					doorY = y1
				}
			} else {
				doorY = y1 + 1 + rand.Intn(buildingWidth-2)
				if sideOfStreet {
					doorX = x2
				} else {
					doorX = x1
				}
			}
			world.NewTile("door", doorX, doorY)
			// Lock door if residential
			if b.T == worldmap.Residential {
				world.Door(doorX, doorY).Lock()
			}
			b.DoorLocation = &worldmap.Coordinates{doorX, doorY}

			// If not residential add counter
			if b.T != worldmap.Residential {
				// Choose the side flap will appear
				flapSide := rand.Intn(2) == 0
				if t.Horizontal {
					counterY := 0
					if sideOfStreet {
						counterY = y1 + 2
					} else {
						counterY = y2 - 2
					}

					for x := x1 + 1; x < x2; x++ {
						world.NewTile("counter", x, counterY)
					}

					if flapSide {
						world.NewTile("counter flap", x1+1, counterY)
					} else {
						world.NewTile("counter flap", x2-1, counterY)
					}
				} else {
					counterX := 0
					if sideOfStreet {
						counterX = x1 + 2
					} else {
						counterX = x2 - 2
					}

					for y := y1 + 1; y < y2; y++ {
						world.NewTile("counter", counterX, y)
					}

					if flapSide {
						world.NewTile("counter flap", counterX, y1+1)
					} else {
						world.NewTile("counter flap", counterX, y2-1)
					}
				}

			}
			// Add number of windows according total perimeter of building
			perimeter := 2*buildingWidth + 2*depth
			minNumWindows := perimeter / 5
			maxNumWindows := perimeter / 3
			numWindows := minNumWindows + rand.Intn(maxNumWindows-minNumWindows)

			for i := 0; i < numWindows; i++ {

				wallSelection := rand.Intn(4)
				wX, wY := 0, 0

				switch wallSelection {
				case 0:
					windowX := x1 + 1 + rand.Intn(x2-x1-2)
					wX, wY = windowX, y1
				case 1:
					windowX := x1 + 1 + rand.Intn(x2-x1-2)
					wX, wY = windowX, y2
				case 2:
					windowY := y1 + 1 + rand.Intn(y2-y1-2)
					wX, wY = x2, windowY
				case 3:
					windowY := y1 + 1 + rand.Intn(y2-y1-2)
					wX, wY = x1, windowY
				}

				// If a door is not in place, add window. Otherwise, try again.
				if wX != doorX && wY != doorY {
					world.NewTile("window", wX, wY)
				} else {
					i--
				}

			}

			*buildings = append(*buildings, b)
			t.Buildings = append(t.Buildings, b)
		}
	}
}

func generateRandomBuildingInTown(world worldmap.World, t *worldmap.Town, buildings *[]worldmap.Building) {
	generateBuildingInTown(world, t, buildings, randomBuildingType(buildings))
}

func validTown(world worldmap.World, towns *[]worldmap.Town, buildings *[]worldmap.Building, minimum, maximum int) *worldmap.Town {
	// Generate area of town

	width := world.Width()
	height := world.Height()

	valid := false

	for !valid {
		townWidth := minimum + rand.Intn(maximum-minimum)
		townHeight := minimum + rand.Intn(maximum-minimum)

		posWidth := 0
		negWidth := 0
		posHeight := 0
		negHeight := 0

		if townWidth%2 == 0 {
			posWidth, negWidth = townWidth/2, townWidth/2
		} else {
			posWidth, negWidth = (townWidth+1)/2, townWidth/2
		}

		if townHeight%2 == 0 {
			posHeight, negHeight = townHeight/2, townHeight/2
		} else {
			posHeight, negHeight = (townHeight+1)/2, townHeight/2
		}

		// stop it from reaching the edges of the map
		cX := rand.Intn(width-posWidth) + negWidth
		cY := rand.Intn(height-posHeight) + negHeight

		x1, y1 := cX-negWidth, cY-negHeight
		x2, y2 := cX+posWidth, cY+posHeight

		streetBreadth := 1 + rand.Intn(5)

		streetX1, streetY1 := 0, 0
		streetX2, streetY2 := 0, 0

		horizontalStreet := rand.Intn(2) == 0
		if horizontalStreet {
			streetX1, streetY1 = x1, cY-streetBreadth/2
			streetX2, streetY2 = x2, cY+(streetBreadth+1)/2
		} else {
			streetX1, streetY1 = cX-streetBreadth/2, y1
			streetX2, streetY2 = cX+(streetBreadth+1)/2, y2
		}

		t := worldmap.NewTown(generateTownName(), x1, y1, x2, y2, streetX1, streetY1, streetX2, streetY2, horizontalStreet, false)

		valid := isValid(x1, y1, width, height) && isValid(x2, y2, width, height) && !townsOverlap(*towns, *t)
		if valid {
			return t
		}
	}
	return nil
}

// Generate small town (single street with buildings)
func generateTown(world worldmap.World, towns *[]worldmap.Town, buildings *[]worldmap.Building) {
	town := validTown(world, towns, buildings, 20, 50)
	townWidth := 0
	if town.Horizontal {
		townWidth = town.TownArea.X2() - town.TownArea.X1()
	} else {
		townWidth = town.TownArea.Y2() - town.TownArea.Y1()
	}
	minNumBuildings, maxNumBuildings := int(math.Max(1, float64(townWidth/20))), int(math.Max(1, float64(townWidth/5)))
	numBuildings := minNumBuildings + rand.Intn(maxNumBuildings-minNumBuildings)
	// Generate a number of buildings
	for i := 0; i < numBuildings; i++ {
		generateRandomBuildingInTown(world, town, buildings)
	}
	*towns = append(*towns, *town)
}

func generateFarm(world worldmap.World, towns *[]worldmap.Town, buildings *[]worldmap.Building) {
	town := validTown(world, towns, buildings, 30, 60)
	town.Farm = true

	// Generate fields

	if town.Horizontal {

		for side := 0; side <= 1; side++ {
			position := town.TownArea.X1()
			for position < town.TownArea.X2() {
				// Choose random crop
				crop := item.RandomItemName([]string{"corn", "potato"})
				// Random width
				width := rand.Intn(town.TownArea.X2() - position)
				for x := position; x < position+width; x++ {
					if side == 0 {
						for y := town.TownArea.Y1(); y < town.StreetArea.Y1(); y++ {
							world.PlaceItem(x, y, item.NewItem(crop))
						}
					} else {
						for y := town.StreetArea.Y2() + 1; y <= town.TownArea.Y2(); y++ {
							world.PlaceItem(x, y, item.NewItem(crop))
						}
					}
				}
				position += width + 1
			}
		}
	} else {

		for side := 0; side <= 1; side++ {
			position := town.TownArea.Y1()
			for position < town.TownArea.Y2() {
				// Choose random crop
				crop := item.RandomItemName([]string{"corn", "potato"})
				// Random width
				width := rand.Intn(town.TownArea.Y2() - position)
				for y := position; y < position+width; y++ {
					if side == 0 {
						for x := town.TownArea.X1(); x < town.StreetArea.X1(); x++ {
							world.PlaceItem(x, y, item.NewItem(crop))
						}
					} else {
						for x := town.StreetArea.X2() + 1; x <= town.TownArea.X2(); x++ {
							world.PlaceItem(x, y, item.NewItem(crop))
						}
					}
				}
				position += width + 1
			}
		}
	}

	// Generate farmhouse
	generateBuildingInTown(world, town, buildings, worldmap.Residential)
	*towns = append(*towns, *town)

}

func generateTownName() string {
	noun := npc.Names.Towns["Nouns"][rand.Intn(len(npc.Names.Towns["Nouns"]))]
	withAdjective := rand.Intn(2) == 0
	if withAdjective {
		adjective := npc.Names.Towns["Adjectives"][rand.Intn(len(npc.Names.Towns["Adjectives"]))]

		joined := rand.Intn(2) == 0
		if joined {
			return adjective + strings.ToLower(noun)
		} else {
			return adjective + " " + noun
		}
	}
	return noun
}

type path struct {
	curves []func(float64) worldmap.Coordinates
	width  int
}

func generatePaths(world worldmap.World, towns []worldmap.Town) {
	// Create tiles in towns
	for _, t := range towns {
		for y := t.StreetArea.Y1(); y <= t.StreetArea.Y2(); y++ {
			for x := t.StreetArea.X1(); x <= t.StreetArea.X2(); x++ {
				world.NewTile("path", x, y)
			}
		}
	}

	// Determine which towns should be connected

	type connection struct {
		first  int
		second int
	}

	connections := make([]connection, 0)
	visitedTowns := structs.Initialise()
	queue := structs.Queue{}

	// choose a starting town
	queue.Enqueue(rand.Intn(len(towns)))

	for !queue.IsEmpty() {
		t := queue.Dequeue().(int)
		if !visitedTowns.Exists(t) {
			visitedTowns.Add(t)
			// Choose up to 3 towns to connect to
			num := 1 + rand.Intn(3)
			for i := 0; i < num; i++ {
				newT := rand.Intn(len(towns))
				if newT != t {
					connectionExists := false
					for _, c := range connections {
						if (c.first == t && c.second == newT) || (c.first == newT && c.second == t) {
							connectionExists = true
							break
						}
					}

					if connectionExists {
						continue
					}

					connections = append(connections, connection{t, newT})
					queue.Enqueue(newT)
				} else {
					i--
				}
			}
		}
	}

	// Define paths mathematically
	paths := make([]path, len(connections))

	for i, c := range connections {
		t1 := towns[c.first]
		t2 := towns[c.second]

		t1StreetPoints := make([]worldmap.Coordinates, 2)
		t2StreetPoints := make([]worldmap.Coordinates, 2)
		t1Width, t2Width := 0, 0

		if t1.Horizontal {
			t1StreetPoints[0] = worldmap.Coordinates{t1.StreetArea.X1(), (t1.StreetArea.Y1() + t1.StreetArea.Y2()) / 2}
			t1StreetPoints[1] = worldmap.Coordinates{t1.StreetArea.X2(), (t1.StreetArea.Y1() + t1.StreetArea.Y2()) / 2}
			t1Width = t1.StreetArea.Y2() - t1.StreetArea.Y1() + 1
		} else {
			t1StreetPoints[0] = worldmap.Coordinates{(t1.StreetArea.X1() + t1.StreetArea.X2()) / 2, t1.StreetArea.Y1()}
			t1StreetPoints[1] = worldmap.Coordinates{(t1.StreetArea.X1() + t1.StreetArea.X2()) / 2, t1.StreetArea.Y2()}
			t1Width = t1.StreetArea.X2() - t1.StreetArea.X1() + 1
		}

		if t2.Horizontal {
			t2StreetPoints[0] = worldmap.Coordinates{t2.StreetArea.X1(), (t2.StreetArea.Y1() + t2.StreetArea.Y2()) / 2}
			t2StreetPoints[1] = worldmap.Coordinates{t2.StreetArea.X2(), (t2.StreetArea.Y1() + t2.StreetArea.Y2()) / 2}
			t2Width = t2.StreetArea.Y2() - t2.StreetArea.Y1() + 1
		} else {
			t2StreetPoints[0] = worldmap.Coordinates{(t2.StreetArea.X1() + t2.StreetArea.X2()) / 2, t2.StreetArea.Y1()}
			t2StreetPoints[1] = worldmap.Coordinates{(t2.StreetArea.X1() + t2.StreetArea.X2()) / 2, t2.StreetArea.Y2()}
			t2Width = t2.StreetArea.X2() - t2.StreetArea.X1() + 1
		}

		width := (t1Width + t2Width) / 2

		intersects := true
		curves := make([]func(float64) worldmap.Coordinates, width+1)
		for intersects {
			intersects = false

			start := t1StreetPoints[rand.Intn(2)]
			end := t2StreetPoints[rand.Intn(2)]

			// Calculate all start and end points
			startPoints := make([]worldmap.Coordinates, width+1)
			endPoints := make([]worldmap.Coordinates, width+1)

			// Pick control points of the bezier curve
			// They should be close enough to the line to not have too tight corners
			r := int(worldmap.Distance(start.X, start.Y, end.X, end.Y) / 2)
			centre := worldmap.Coordinates{(start.X + end.X) / 2, (start.Y + end.Y) / 2}
			c1 := worldmap.Coordinates{centre.X + int(math.Pow(-1.0, float64(rand.Intn(2)))*float64(rand.Intn(r))),
				centre.Y + int(math.Pow(-1.0, float64(rand.Intn(2)))*float64(rand.Intn(r)))}
			c2 := worldmap.Coordinates{centre.X + int(math.Pow(-1.0, float64(rand.Intn(2)))*float64(rand.Intn(r))),
				centre.Y + int(math.Pow(-1.0, float64(rand.Intn(2)))*float64(rand.Intn(r)))}

			for j := 0; j <= width; j++ {
				if t1.Horizontal {
					startPoints[j] = worldmap.Coordinates{start.X, start.Y + j - width/2}
				} else {
					startPoints[j] = worldmap.Coordinates{start.X + j - width/2, start.Y}
				}

				if t2.Horizontal {
					endPoints[j] = worldmap.Coordinates{end.X, end.Y + j - width/2}
				} else {
					endPoints[j] = worldmap.Coordinates{end.X + j - width/2, end.Y}
				}
			}

			curve := func(start, end worldmap.Coordinates) func(t float64) worldmap.Coordinates {
				return func(t float64) worldmap.Coordinates {
					// This is just definition of a cubic bezier curve
					x := int(math.Pow(1-t, 3)*float64(start.X) + 3*(1-t)*(1-t)*t*float64(c1.X) + 3*(1-t)*t*t*float64(c2.X) + math.Pow(t, 3)*float64(end.X))
					y := int(math.Pow(1-t, 3)*float64(start.Y) + 3*(1-t)*(1-t)*t*float64(c1.Y) + 3*(1-t)*t*t*float64(c2.Y) + math.Pow(t, 3)*float64(end.Y))
					return worldmap.Coordinates{x, y}
				}
			}

			// check that path does not intersect towns
			minStep := 1.0 / (2 * math.Max(math.Abs(float64(end.X-start.X)), math.Abs(float64(end.Y-start.Y))))

			for t := 0.0; t <= 1.0; t += minStep {
				point := curve(start, end)(t)
				for _, town := range towns {
					if point.X > town.TownArea.X1() && point.X < town.TownArea.X2() && point.Y > town.TownArea.Y1() && point.Y < town.TownArea.Y2() {
						intersects = true
					}
				}
				if intersects {
					break
				}

			}

			if !intersects {
				for j := 0; j <= width; j++ {
					curves[j] = curve(startPoints[j], endPoints[j])
				}
			}
		}
		paths[i] = path{curves, width}
	}

	// Create tiles for paths

	for _, path := range paths {
		generatePath(world, path)
	}

}

func generatePath(world worldmap.World, path path) {
	start := path.curves[0](0.0)
	end := path.curves[0](1.0)

	minStep := 1.0 / (10 * math.Max(math.Abs(float64(end.X-start.X)), math.Abs(float64(end.Y-start.Y))))

	for _, curve := range path.curves {
		for t := 0.0; t <= 1.0; t += minStep {
			curr := curve(t)
			if curr.X >= 0 && curr.X < world.Width() && curr.Y >= 0 && curr.Y < world.Height() {
				world.NewTile("path", curr.X, curr.Y)
			}
		}
	}
}

func placeSignposts(m worldmap.World, towns []worldmap.Town) {
	for _, t := range towns {
		sX, sY := 0, 0

		if t.Horizontal {
			sY = [2]int{t.StreetArea.Y1() - 2, t.StreetArea.Y2() + 2}[rand.Intn(2)]
			sX = [2]int{t.StreetArea.X1(), t.StreetArea.X2()}[rand.Intn(2)]
		} else {
			sX = [2]int{t.StreetArea.X1() - 2, t.StreetArea.X2() + 2}[rand.Intn(2)]
			sY = [2]int{t.StreetArea.Y1(), t.StreetArea.Y2()}[rand.Intn(2)]
		}

		signpost := item.NewReadable("signpost", map[string]string{"town": t.Name})
		// Make it belong to the town so if it's stolen the character who has done it has committed a CrimeEvent
		signpost.TransferOwner(t.Name)

		m.PlaceItem(sX, sY, signpost)

	}
}

func generatePlayerLocation(world worldmap.World, towns []worldmap.Town) worldmap.Coordinates {
	normalTowns := make([]worldmap.Town, 0)
	for _, t := range towns {
		if !t.Farm {
			normalTowns = append(normalTowns, t)
		}
	}

	locationFound := false
	location := worldmap.Coordinates{}
	for !locationFound {
		t := normalTowns[rand.Intn(len(normalTowns))]

		x, y := t.TownArea.X1()-10+rand.Intn(t.TownArea.X2()-t.TownArea.X1()+10), t.TownArea.Y1()-10+rand.Intn(t.TownArea.Y2()-t.TownArea.Y1()+10)
		inside := x >= t.TownArea.X1() && x <= t.TownArea.X2() && y >= t.TownArea.Y1() && y <= t.TownArea.Y2()
		if world.IsValid(x, y) && world.IsPassable(x, y) && !world.IsOccupied(x, y) && !inside {
			locationFound = true
			location = worldmap.Coordinates{x, y}
		}
	}

	return location
}

func generateMounts(m worldmap.World, buildings []worldmap.Building, n int) []*npc.Npc {
	width := m.Width()
	height := m.Height()
	mounts := make([]*npc.Npc, n)
	for i := 0; i < n; i++ {
		x := rand.Intn(width)
		y := rand.Intn(height)
		if !m.IsPassable(x, y) || m.IsOccupied(x, y) || !outside(buildings, x, y) {
			i--
			continue
		}
		mounts[i] = npc.NewMount("horse", x, y, nil)
		m.Place(mounts[i])
	}
	return mounts
}

func generateEnemies(m worldmap.World, n int) []*npc.Npc {
	width := m.Width()
	height := m.Height()
	enemies := make([]*npc.Npc, n)
	for i := 0; i < n; i++ {
		x := rand.Intn(width)
		y := rand.Intn(height)
		if !m.IsPassable(x, y) || m.IsOccupied(x, y) {
			i--
			continue
		}
		enemies[i] = npc.NewEnemy(npc.RandomEnemyType(), x, y, nil)
		m.Place(enemies[i])

	}
	return enemies
}

func generateNpcs(m worldmap.World, towns []worldmap.Town, buildings []worldmap.Building, n int) []*npc.Npc {
	width := m.Width()
	height := m.Height()
	npcs := make([]*npc.Npc, 0)

	usedBuildings := make([]worldmap.Building, 0)

	commercialBuildings := make([]worldmap.Building, 0)
	for _, b := range buildings {
		if b.T != worldmap.Residential {
			commercialBuildings = append(commercialBuildings, b)
		}
	}
	i := 0

	// Place npcs in commerical buildings first
	for ; i < n && i < len(commercialBuildings); i++ {
		b := commercialBuildings[i]
		switch b.T {
		case worldmap.GunShop:
			placeNpcInBuilding(m, &npcs, findTown(towns, b), b, "shopkeeper")
		case worldmap.Saloon:
			placeNpcInBuilding(m, &npcs, findTown(towns, b), b, "bartender")
			buildingArea := (b.Area.X2() - b.Area.X1()) * (b.Area.Y2() - b.Area.Y1())
			numPatrons := rand.Intn(buildingArea / 5)
			for j := 0; j < numPatrons; j++ {
				placeNpcInBuilding(m, &npcs, findTown(towns, b), b, "bar patron")
			}
		case worldmap.Sheriff:
			placeNpcInBuilding(m, &npcs, findTown(towns, b), b, "sheriff")
			numDeputies := rand.Intn(3)
			for j := 0; j < numDeputies; j++ {
				placeNpcInBuilding(m, &npcs, findTown(towns, b), b, "deputy")
			}
		}
		usedBuildings = append(usedBuildings, b)
	}

	// Place farmers and animals in farms
	for _, town := range towns {
		if town.Farm {
			placeNpcInBuilding(m, &npcs, town, town.Buildings[0], "farmer")
			townArea := (town.TownArea.X2() - town.TownArea.X1()) * (town.TownArea.Y2() - town.TownArea.Y1())
			numberAnimals := townArea / 100
			for j := 0; j < numberAnimals; j++ {
				x, y := town.TownArea.X1()+rand.Intn(town.TownArea.X2()-town.TownArea.X1()), town.TownArea.Y1()+rand.Intn(town.TownArea.Y2()-town.TownArea.Y1())
				if !m.IsPassable(x, y) || m.IsOccupied(x, y) {
					j--
					continue
				}
				animalType := npc.RandomNpcTypeFromSelection([]string{"cow", "pig", "chicken"})
				c := npc.NewNpc(animalType, x, y, nil, nil, nil, nil)
				m.Place(c)
				npcs = append(npcs, c)
			}
			i++
		}
	}

	for ; i < n; i++ {
		x, y := 0, 0

		// 50/50 chance of being placed inside or outside a building
		insideBuilding := rand.Intn(2) == 0
		if insideBuilding {
			b := buildings[rand.Intn(len(buildings))]
			usedBefore := false
			for _, building := range usedBuildings {
				if b == building {
					usedBefore = true
				}
			}

			if usedBefore {
				i--
				continue
			}
			placeNpcInBuilding(m, &npcs, findTown(towns, b), b, "townsman")
			usedBuildings = append(usedBuildings, b)

		} else {
			x, y = rand.Intn(width), rand.Intn(height)
			if !m.IsPassable(x, y) || m.IsOccupied(x, y) {
				i--
				continue
			}
			npcType := npc.RandomNpcType()
			c := npc.NewNpc(npcType, x, y, nil, nil, nil, nil)
			m.Place(c)
			npcs = append(npcs, c)
			protector := generateProtector(m, npcType, c)
			if protector != nil {
				npcs = append(npcs, protector)
				m.Place(protector)
			}
		}
	}
	return npcs
}

func generateProtector(m worldmap.World, npcType string, c worldmap.Creature) *npc.Npc {
	pX, pY := c.GetCoordinates()
	r := 5
	for {
		x, y := pX+rand.Intn(2*r)-r, pY+rand.Intn(2*r)-r
		if m.IsValid(x, y) && m.IsPassable(x, y) && !m.IsOccupied(x, y) {
			return npc.AddProtector(npcType, x, y, c.GetID())
		}
	}
}

func placeNpcInBuilding(m worldmap.World, npcs *[]*npc.Npc, t worldmap.Town, b worldmap.Building, npcType string) {
	var n *npc.Npc
	for n == nil {
		x := b.Area.X1() + 1 + rand.Intn(b.Area.X2()-b.Area.X1()-1)
		y := b.Area.Y1() + 1 + rand.Intn(b.Area.Y2()-b.Area.Y1()-1)

		if !m.IsPassable(x, y) || m.IsOccupied(x, y) {
			continue
		}

		if npcType == "townsman" {
			n = npc.NewNpc(npcType, x, y, nil, nil, nil, nil)
		} else {
			n = npc.NewNpc(npcType, x, y, nil, &t, &b, nil)
		}
		*npcs = append(*npcs, n)
		m.Place(n)
		protector := generateProtector(m, npcType, n)
		if protector != nil {
			*npcs = append(*npcs, protector)
			m.Place(protector)
		}
	}
}

func findTown(towns []worldmap.Town, b worldmap.Building) worldmap.Town {
	// Find town building is in
	for _, town := range towns {
		for _, building := range town.Buildings {
			if building == b {
				return town
			}
		}
	}
	return worldmap.Town{}
}

func isValid(x, y, width, height int) bool {
	return x >= 0 && y >= 0 && x < width && y < height
}

func outside(buildings []worldmap.Building, x, y int) bool {
	for _, b := range buildings {
		if b.Inside(x, y) {
			return false
		}
	}
	return true
}

func inTown(t worldmap.Town, b worldmap.Building) bool {
	return b.Area.X1() >= t.TownArea.X1() && b.Area.X1() <= t.TownArea.X2() && b.Area.X2() >= t.TownArea.X1() && b.Area.X2() <= t.TownArea.X2() && b.Area.Y1() >= t.TownArea.Y1() && b.Area.Y1() <= t.TownArea.Y2() && b.Area.Y2() >= t.TownArea.Y1() && b.Area.Y2() <= t.TownArea.Y2()
}

func inTowns(towns []worldmap.Town, b worldmap.Building) bool {
	for _, t := range towns {
		if inTown(t, b) {
			return true
		}
	}
	return false
}

func overlap(buildings []worldmap.Building, b worldmap.Building) bool {
	for _, otherBuilding := range buildings {
		if !(b.Area.X2() < otherBuilding.Area.X1()-1 || otherBuilding.Area.X2() < b.Area.X1()-1 || b.Area.Y2() < otherBuilding.Area.Y1()-1 || otherBuilding.Area.Y2() < b.Area.Y1()-1) {
			return true
		}
	}
	return false

}

func townsOverlap(towns []worldmap.Town, t worldmap.Town) bool {
	for _, otherTown := range towns {
		if !(t.TownArea.X2() < otherTown.TownArea.X1() || otherTown.TownArea.X2() < t.TownArea.X1() || t.TownArea.Y2() < otherTown.TownArea.Y1() || otherTown.TownArea.Y2() < t.TownArea.Y1()) {
			return true
		}

		t1cX, t1cY := (t.TownArea.X1()+t.TownArea.X2())/2, (t.TownArea.Y1()+t.TownArea.Y2())/2
		t2cX, t2cY := (otherTown.TownArea.X1()+otherTown.TownArea.X2())/2, (otherTown.TownArea.Y1()+otherTown.TownArea.Y2())/2
		distance := math.Sqrt(math.Pow(float64(t1cX-t2cX), 2) + math.Pow(float64(t1cY-t2cY), 2))

		if distance < 40 {
			return true
		}
	}
	return false

}
